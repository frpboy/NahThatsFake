<p><strong>üîç Nah That's Fake</strong></p><p>Database Schema</p><p>Document 10 of 13</p><p>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</p><p><strong>Document: </strong>Document 10 of 13 ‚Äî Database Schema</p><p><strong>Version: </strong>v1.0 ‚Äî MVP</p><p><strong>Date: </strong>February 2026</p><p><strong>Status: </strong>Draft ‚Äî Deploy to Supabase Before Testing</p><p><strong>Database: </strong>Supabase (PostgreSQL)</p><p><strong>Bot Handle: </strong>@NahThatsFakeBot</p><table><tr><td><p><strong>üóÑÔ∏è What This Document Covers</strong></p><p>The complete database schema for Nah That's Fake ‚Äî every table, column, type,</p><p>constraint, index, and RLS policy needed to run the product.</p><p>Covers: 7 tables (users, checks, check_cache, payments, referrals, groups, abuse_flags)</p><p>Full SQL migration scripts ‚Äî copy/paste into Supabase SQL editor to deploy.</p><p>Index strategy, RLS policies, and common query patterns.</p></td></tr></table><h1><strong>1. Schema Overview</strong></h1><p>The database has 7 tables. Here is how they relate to each other and what each one does.</p><table><thead><tr><th><p><strong>Table</strong></p></th><th><p><strong>Purpose</strong></p></th><th><p><strong>Primary Key</strong></p></th><th><p><strong>Key Relationships</strong></p></th></tr></thead><tbody><tr><td><p>users</p></td><td><p>One row per Telegram user. Source of truth for plan, credits, consent.</p></td><td><p>id (uuid)</p></td><td><p>Referenced by all other tables</p></td></tr><tr><td><p>checks</p></td><td><p>One row per check performed. Full history of all scans.</p></td><td><p>id (uuid)</p></td><td><p>user_id ‚Üí users.id</p></td></tr><tr><td><p>check_cache</p></td><td><p>Deduplication cache. Avoids re-calling APIs for seen content.</p></td><td><p>id (uuid)</p></td><td><p>Standalone ‚Äî keyed on content_hash</p></td></tr><tr><td><p>payments</p></td><td><p>Every payment attempt (success or failure).</p></td><td><p>id (uuid)</p></td><td><p>user_id ‚Üí users.id</p></td></tr><tr><td><p>referrals</p></td><td><p>Tracks referral relationships and credit status.</p></td><td><p>id (uuid)</p></td><td><p>referrer_id + referee_id ‚Üí users.id</p></td></tr><tr><td><p>groups</p></td><td><p>One row per Telegram group the bot is installed in.</p></td><td><p>id (uuid)</p></td><td><p>Standalone ‚Äî keyed on telegram_group_id</p></td></tr><tr><td><p>abuse_flags</p></td><td><p>Abuse detection log. Flagged users and actions.</p></td><td><p>id (uuid)</p></td><td><p>user_id ‚Üí users.id</p></td></tr></tbody></table><table><tr><td><p><strong>‚ö° Deploy Order</strong></p><p>Run the migration scripts in this order ‚Äî foreign key constraints require it:</p><p>  1. users</p><p>  2. groups</p><p>  3. checks</p><p>  4. check_cache</p><p>  5. payments</p><p>  6. referrals</p><p>  7. abuse_flags</p><p>  8. Indexes (Section 8)</p><p>  9. RLS Policies (Section 9)</p></td></tr></table><h1><strong>2. Table: users</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>users</strong></p></td><td><p>Core user table ‚Äî one row per Telegram user. Source of truth for plan, credits, and consent.</p></td></tr></table><table><tr><td><p>CREATE TABLE users (</p><p>  id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  telegram_user_id    TEXT NOT NULL UNIQUE,        -- Telegram's numeric ID as text</p><p>  username            TEXT,                        -- @handle (nullable, user may have none)</p><p>  first_name          TEXT,                        -- From Telegram profile</p><p>  last_name           TEXT,                        -- From Telegram profile (nullable)</p><p>  -- Plan &amp; Premium</p><p>  plan                TEXT NOT NULL DEFAULT 'free' -- 'free'|'ind_monthly'|'ind_annual'|'grp_monthly'</p><p>                      CHECK (plan IN ('free','ind_monthly','ind_annual','grp_monthly')),</p><p>  premium_until       TIMESTAMPTZ,                 -- NULL = free user</p><p>  grace_until         TIMESTAMPTZ,                 -- premium_until + 3 days</p><p>  payment_method      TEXT,                        -- 'razorpay'|'stars'|NULL</p><p>  last_payment_id     TEXT,</p><p>  last_paid_at        TIMESTAMPTZ,</p><p>  -- Credits</p><p>  permanent_credits   INTEGER NOT NULL DEFAULT 0   CHECK (permanent_credits &gt;= 0),</p><p>  -- Referral</p><p>  referral_code       TEXT UNIQUE,                 -- User's own code for sharing</p><p>  referred_by         TEXT,                        -- referral_code of who referred them</p><p>  -- Consent &amp; Onboarding</p><p>  consent_given       BOOLEAN NOT NULL DEFAULT FALSE,</p><p>  consent_at          TIMESTAMPTZ,</p><p>  onboarding_complete BOOLEAN NOT NULL DEFAULT FALSE,</p><p>  -- Metadata</p><p>  created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  last_active_at      TIMESTAMPTZ,</p><p>  is_banned           BOOLEAN NOT NULL DEFAULT FALSE</p><p>);</p></td></tr></table><table><thead><tr><th><p><strong>Column</strong></p></th><th><p><strong>Type</strong></p></th><th><p><strong>Nullable</strong></p></th><th><p><strong>Notes</strong></p></th></tr></thead><tbody><tr><td><p>telegram_user_id</p></td><td><p>TEXT UNIQUE</p></td><td><p>No</p></td><td><p>Telegram's user ID. Always store as text ‚Äî can exceed int32.</p></td></tr><tr><td><p>plan</p></td><td><p>TEXT CHECK</p></td><td><p>No</p></td><td><p>Enum-constrained. Default 'free'. Changed on payment.</p></td></tr><tr><td><p>premium_until</p></td><td><p>TIMESTAMPTZ</p></td><td><p>Yes</p></td><td><p>NULL = free. Set to NOW()+30d or NOW()+365d on payment.</p></td></tr><tr><td><p>grace_until</p></td><td><p>TIMESTAMPTZ</p></td><td><p>Yes</p></td><td><p>premium_until + 3 days. User retains access until this passes.</p></td></tr><tr><td><p>permanent_credits</p></td><td><p>INTEGER</p></td><td><p>No</p></td><td><p>CHECK &gt;= 0. Incremented on referral. Never decremented below 0.</p></td></tr><tr><td><p>referral_code</p></td><td><p>TEXT UNIQUE</p></td><td><p>Yes</p></td><td><p>Generated on first /refer command. Format: 8 random alphanumeric chars.</p></td></tr><tr><td><p>consent_given</p></td><td><p>BOOLEAN</p></td><td><p>No</p></td><td><p>Must be TRUE before any check is processed.</p></td></tr></tbody></table><h1><strong>3. Table: checks</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>checks</strong></p></td><td><p>One row per check performed. Full audit trail of all scans ‚Äî image and link.</p></td></tr></table><table><tr><td><p>CREATE TABLE checks (</p><p>  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  user_id         UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p><p>  group_id        UUID REFERENCES groups(id) ON DELETE SET NULL, -- NULL = private chat</p><p>  -- Content</p><p>  check_type      TEXT NOT NULL CHECK (check_type IN ('image', 'link')),</p><p>  content_hash    TEXT NOT NULL,   -- SHA-256 of image bytes OR normalised URL</p><p>  -- Result</p><p>  score           NUMERIC(5,4),    -- 0.0000 to 1.0000 (4 decimal places)</p><p>  risk_level      TEXT CHECK (risk_level IN ('HIGH', 'MEDIUM', 'LOW')),</p><p>  raw_response    JSONB,           -- Full API response for debugging</p><p>  -- Source</p><p>  cached          BOOLEAN NOT NULL DEFAULT FALSE,</p><p>  api_source      TEXT,            -- 'sightengine'|'google_safe_browsing'|'virustotal'|'combined'</p><p>  exif_present    BOOLEAN,         -- Image only: was EXIF metadata present?</p><p>  -- Credit tracking</p><p>  credit_source   TEXT CHECK (credit_source IN ('daily','permanent','premium','group')),</p><p>  -- Error tracking</p><p>  error           TEXT,            -- NULL = success. Error message if failed.</p><p>  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()</p><p>);</p></td></tr></table><table><tr><td><p><strong>üí° Why Store raw_response as JSONB?</strong></p><p>The raw_response column stores the complete API response (Sightengine or VirusTotal output).</p><p>This is invaluable for debugging false positives ‚Äî if a user reports an incorrect result,</p><p>you can look up exactly what the API returned without re-scanning the content.</p><p>Retention: raw_response is cleared after 30 days for free users, 90 days for premium.</p><p>The score, risk_level, and content_hash are retained permanently for analytics.</p></td></tr></table><h1><strong>4. Table: check_cache</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>check_cache</strong></p></td><td><p>Deduplication cache. Prevents re-calling APIs for identical content. 30-day TTL for images, 7-day for links.</p></td></tr></table><table><tr><td><p>CREATE TABLE check_cache (</p><p>  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  check_type      TEXT NOT NULL CHECK (check_type IN ('image', 'link')),</p><p>  content_hash    TEXT NOT NULL,   -- SHA-256 of image bytes OR normalised URL</p><p>  score           NUMERIC(5,4) NOT NULL,</p><p>  risk_level      TEXT NOT NULL CHECK (risk_level IN ('HIGH', 'MEDIUM', 'LOW')),</p><p>  api_source      TEXT,</p><p>  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  expires_at      TIMESTAMPTZ NOT NULL,  -- created_at + 30d (image) or 7d (link)</p><p>  UNIQUE (check_type, content_hash)  -- Prevent duplicate cache entries</p><p>);</p></td></tr></table><table><tr><td><p><strong>üîÑ Cache Logic (set in application code, not DB triggers)</strong></p><p>On every check BEFORE calling external APIs:</p><p>  SELECT * FROM check_cache</p><p>  WHERE check_type = $1 AND content_hash = $2 AND expires_at &gt; NOW();</p><p>  Cache HIT  ‚Üí return cached result immediately. No API call.</p><p>  Cache MISS ‚Üí call API ‚Üí INSERT into check_cache with correct expires_at:</p><p>               Images: expires_at = NOW() + INTERVAL '30 days'</p><p>               Links:  expires_at = NOW() + INTERVAL '7 days'</p><p>On INSERT, use ON CONFLICT (check_type, content_hash) DO UPDATE to refresh expiry.</p><p>Run a daily Supabase pg_cron job to DELETE FROM check_cache WHERE expires_at &lt; NOW();</p></td></tr></table><h1><strong>5. Table: payments</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>payments</strong></p></td><td><p>Immutable log of every payment attempt. Never update rows ‚Äî only insert. Source of truth for billing.</p></td></tr></table><table><tr><td><p>CREATE TABLE payments (</p><p>  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  user_id          UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,</p><p>                   -- ON DELETE RESTRICT: cannot delete user with payment history</p><p>  -- Plan</p><p>  plan_id          TEXT NOT NULL,   -- 'ind_monthly'|'ind_annual'|'grp_monthly'</p><p>  -- Amount</p><p>  amount_inr       INTEGER,         -- In paise (‚Çπ99 = 9900). NULL for Stars payments.</p><p>  amount_stars     INTEGER,         -- Number of Stars. NULL for INR payments.</p><p>  -- Payment method</p><p>  payment_method   TEXT NOT NULL CHECK (payment_method IN ('razorpay', 'stars')),</p><p>  payment_id       TEXT,            -- Razorpay payment_id or Telegram charge_id</p><p>  order_id         TEXT,            -- Razorpay order_id (NULL for Stars)</p><p>  -- Status</p><p>  status           TEXT NOT NULL</p><p>                   CHECK (status IN ('success','failed','refunded','pending')),</p><p>  -- Premium period granted</p><p>  premium_from     TIMESTAMPTZ,     -- When premium started (on success)</p><p>  premium_until    TIMESTAMPTZ,     -- When premium ends (on success)</p><p>  -- Group (if group premium)</p><p>  group_id         UUID REFERENCES groups(id) ON DELETE SET NULL,</p><p>  -- Audit</p><p>  created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  webhook_received_at TIMESTAMPTZ, -- When webhook confirmed payment</p><p>  notes            TEXT            -- Internal notes (e.g. refund reason)</p><p>);</p></td></tr></table><table><tr><td><p><strong>‚ö†Ô∏è Immutability Rule</strong></p><p>Payments rows must NEVER be updated after creation. If a payment status changes</p><p>(e.g. captured ‚Üí refunded), INSERT a new row with status='refunded' and a reference</p><p>to the original payment_id. This creates a full audit trail.</p><p>Exception: webhook_received_at may be updated when the webhook arrives after</p><p>an initial 'pending' insert.</p></td></tr></table><h1><strong>6. Table: referrals</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>referrals</strong></p></td><td><p>Tracks every referral relationship. One row per referral attempt. Credits only awarded after referee's first check.</p></td></tr></table><table><tr><td><p>CREATE TABLE referrals (</p><p>  id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  -- People</p><p>  referrer_id        UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p><p>  referee_id         UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p><p>  -- Status</p><p>  status             TEXT NOT NULL DEFAULT 'pending'</p><p>                     CHECK (status IN ('pending','credited','expired','invalid')),</p><p>                     -- pending:  referee signed up but hasn't completed first check</p><p>                     -- credited: first check done, both users got credits</p><p>                     -- expired:  referee never completed first check (cleanup)</p><p>                     -- invalid:  fraud detected, credits reversed</p><p>  -- Credit amounts</p><p>  referrer_credits   INTEGER NOT NULL DEFAULT 1,  -- Credits awarded to referrer</p><p>  referee_credits    INTEGER NOT NULL DEFAULT 2,  -- Credits awarded to referee</p><p>  -- Timing</p><p>  created_at         TIMESTAMPTZ NOT NULL DEFAULT NOW(),  -- When referee signed up</p><p>  credited_at        TIMESTAMPTZ,                         -- When first check completed</p><p>  UNIQUE (referrer_id, referee_id)  -- One referral per pair</p><p>);</p></td></tr></table><table><thead><tr><th><p><strong>Status</strong></p></th><th><p><strong>Meaning</strong></p></th><th><p><strong>Transition Trigger</strong></p></th></tr></thead><tbody><tr><td><p>pending</p></td><td><p>Referee signed up via referral link. Awaiting first check.</p></td><td><p>Set on signup via referral link</p></td></tr><tr><td><p>credited</p></td><td><p>First check completed. Both users received credits.</p></td><td><p>Set when referee completes check #1</p></td></tr><tr><td><p>expired</p></td><td><p>30 days passed with no first check. Credits not awarded.</p></td><td><p>Set by daily cleanup job</p></td></tr><tr><td><p>invalid</p></td><td><p>Fraud detected. Credits reversed if already awarded.</p></td><td><p>Set manually on abuse review</p></td></tr></tbody></table><h1><strong>7. Table: groups</strong></h1><table><tr><td><p><strong>TABLE</strong></p><p><strong>groups</strong></p></td><td><p>One row per Telegram group where the bot is installed. Tracks group plan and auto-scan config.</p></td></tr></table><table><tr><td><p>CREATE TABLE groups (</p><p>  id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  telegram_group_id   TEXT NOT NULL UNIQUE,  -- Telegram's chat ID (negative for groups)</p><p>  group_name          TEXT,</p><p>  admin_user_id       UUID REFERENCES users(id) ON DELETE SET NULL,</p><p>  -- Plan</p><p>  plan                TEXT NOT NULL DEFAULT 'free'</p><p>                      CHECK (plan IN ('free','grp_monthly')),</p><p>  premium_until       TIMESTAMPTZ,</p><p>  grace_until         TIMESTAMPTZ,</p><p>  payment_id          UUID REFERENCES payments(id) ON DELETE SET NULL,</p><p>  -- Auto-scan</p><p>  autoscan_enabled    BOOLEAN NOT NULL DEFAULT FALSE,</p><p>  autoscan_threshold  NUMERIC(3,2) NOT NULL DEFAULT 0.85,  -- 0.85 = 85%</p><p>  autoscan_alerts_today INTEGER NOT NULL DEFAULT 0,        -- Reset daily</p><p>  -- Usage</p><p>  checks_today        INTEGER NOT NULL DEFAULT 0,          -- Reset midnight IST</p><p>  total_checks        INTEGER NOT NULL DEFAULT 0,</p><p>  -- Metadata</p><p>  created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p><p>  is_active           BOOLEAN NOT NULL DEFAULT TRUE        -- FALSE = bot removed</p><p>);</p></td></tr></table><h2><strong>7.2 Table: abuse_flags</strong></h2><table><tr><td><p><strong>TABLE</strong></p><p><strong>abuse_flags</strong></p></td><td><p>Audit log of all abuse events ‚Äî rate limits, fraud, suspicious patterns. Used for manual review.</p></td></tr></table><table><tr><td><p>CREATE TABLE abuse_flags (</p><p>  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p><p>  user_id      UUID REFERENCES users(id) ON DELETE CASCADE,</p><p>  flag_type    TEXT NOT NULL,</p><p>               -- 'rate_limit_exceeded'</p><p>               -- 'referral_farming'</p><p>               -- 'payment_fraud'</p><p>               -- 'multi_account'</p><p>               -- 'spam_checks'</p><p>               -- 'webhook_spoof'</p><p>  details      JSONB,          -- Context: {checks_in_window: 55, window_minutes: 60}</p><p>  auto_action  TEXT,           -- What the system did: 'throttled'|'blocked'|'flagged'</p><p>  reviewed     BOOLEAN NOT NULL DEFAULT FALSE,</p><p>  reviewed_at  TIMESTAMPTZ,</p><p>  reviewed_by  TEXT,           -- Your name/handle when you review</p><p>  resolution   TEXT,           -- 'confirmed_abuse'|'false_positive'|'warning_sent'</p><p>  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()</p><p>);</p></td></tr></table><h1><strong>8. Indexes</strong></h1><p>These indexes are essential for query performance. Run after all tables are created.</p><table><tr><td><p>-- ‚îÄ‚îÄ USERS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_users_telegram_id ON users (telegram_user_id);</p><p>CREATE INDEX idx_users_referral_code ON users (referral_code);</p><p>CREATE INDEX idx_users_plan ON users (plan);</p><p>CREATE INDEX idx_users_premium_until ON users (premium_until);</p><p>-- ‚îÄ‚îÄ CHECKS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_checks_user_id ON checks (user_id);</p><p>CREATE INDEX idx_checks_created_at ON checks (created_at DESC);</p><p>CREATE INDEX idx_checks_user_created ON checks (user_id, created_at DESC);</p><p>CREATE INDEX idx_checks_content_hash ON checks (content_hash);</p><p>CREATE INDEX idx_checks_group_id ON checks (group_id);</p><p>-- ‚îÄ‚îÄ CHECK CACHE ‚îÄ‚îÄ</p><p>-- Already covered by UNIQUE constraint (check_type, content_hash)</p><p>CREATE INDEX idx_cache_expires ON check_cache (expires_at);  -- For cleanup job</p><p>-- ‚îÄ‚îÄ PAYMENTS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_payments_user_id ON payments (user_id);</p><p>CREATE INDEX idx_payments_payment_id ON payments (payment_id);</p><p>CREATE INDEX idx_payments_status ON payments (status);</p><p>CREATE INDEX idx_payments_created_at ON payments (created_at DESC);</p><p>-- ‚îÄ‚îÄ REFERRALS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_referrals_referrer_id ON referrals (referrer_id);</p><p>CREATE INDEX idx_referrals_referee_id ON referrals (referee_id);</p><p>CREATE INDEX idx_referrals_status ON referrals (status);</p><p>-- ‚îÄ‚îÄ GROUPS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_groups_telegram_group_id ON groups (telegram_group_id);</p><p>-- ‚îÄ‚îÄ ABUSE FLAGS ‚îÄ‚îÄ</p><p>CREATE INDEX idx_abuse_user_id ON abuse_flags (user_id);</p><p>CREATE INDEX idx_abuse_reviewed ON abuse_flags (reviewed) WHERE reviewed = FALSE;</p></td></tr></table><h1><strong>9. Row Level Security Policies</strong></h1><p>These policies ensure users can only access their own data from the TMA client. The bot backend uses the service_role key which bypasses RLS ‚Äî this is intentional and necessary.</p><table><tr><td><p>-- ‚ïê‚ïê ENABLE RLS ON ALL TABLES ‚ïê‚ïê</p><p>ALTER TABLE users        ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE checks       ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE check_cache  ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE payments     ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE referrals    ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE groups       ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE abuse_flags  ENABLE ROW LEVEL SECURITY;</p><p>-- ‚ïê‚ïê USERS TABLE ‚ïê‚ïê</p><p>CREATE POLICY users_select_own ON users</p><p>  FOR SELECT USING (telegram_user_id = auth.jwt() -&gt;&gt; 'sub');</p><p>CREATE POLICY users_update_own ON users</p><p>  FOR UPDATE USING (telegram_user_id = auth.jwt() -&gt;&gt; 'sub')</p><p>  WITH CHECK (telegram_user_id = auth.jwt() -&gt;&gt; 'sub');</p><p>-- Users can read/update their own row only</p><p>-- ‚ïê‚ïê CHECKS TABLE ‚ïê‚ïê</p><p>CREATE POLICY checks_select_own ON checks</p><p>  FOR SELECT USING (user_id = (SELECT id FROM users WHERE telegram_user_id = auth.jwt() -&gt;&gt; 'sub'));</p><p>-- Users can only see their own check history</p><p>-- ‚ïê‚ïê PAYMENTS TABLE ‚ïê‚ïê</p><p>CREATE POLICY payments_select_own ON payments</p><p>  FOR SELECT USING (user_id = (SELECT id FROM users WHERE telegram_user_id = auth.jwt() -&gt;&gt; 'sub'));</p><p>-- Users can view their own payment history only</p><p>-- ‚ïê‚ïê CHECK_CACHE TABLE ‚ïê‚ïê</p><p>-- Cache is read-only for TMA (writing done by service_role)</p><p>CREATE POLICY cache_select_all ON check_cache FOR SELECT USING (TRUE);</p><p>-- ‚ïê‚ïê REFERRALS TABLE ‚ïê‚ïê</p><p>CREATE POLICY referrals_select_own ON referrals</p><p>  FOR SELECT USING (</p><p>    referrer_id = (SELECT id FROM users WHERE telegram_user_id = auth.jwt() -&gt;&gt; 'sub')</p><p>    OR</p><p>    referee_id  = (SELECT id FROM users WHERE telegram_user_id = auth.jwt() -&gt;&gt; 'sub')</p><p>  );</p><p>-- Users can see referrals where they are referrer OR referee</p><p>-- ‚ïê‚ïê GROUPS TABLE ‚ïê‚ïê</p><p>CREATE POLICY groups_select_admin ON groups</p><p>  FOR SELECT USING (admin_user_id = (SELECT id FROM users WHERE telegram_user_id = auth.jwt() -&gt;&gt; 'sub'));</p><p>-- Group admins can see their group's data only</p><p>-- ‚ïê‚ïê ABUSE FLAGS ‚ïê‚ïê</p><p>-- TMA should NEVER expose abuse flags to users</p><p>-- No SELECT policy = no access from TMA client</p><p>-- Only accessible via service_role (admin dashboard)</p></td></tr></table><h1><strong>10. Useful Queries</strong></h1><p>Copy these into Supabase SQL editor for monitoring, debugging, and revenue reporting.</p><h2><strong>10.1 Daily Active Users</strong></h2><table><tr><td><p>SELECT DATE(created_at AT TIME ZONE 'Asia/Kolkata') as date,</p><p>       COUNT(DISTINCT user_id) as dau</p><p>FROM checks</p><p>WHERE created_at &gt; NOW() - INTERVAL '30 days'</p><p>GROUP BY 1 ORDER BY 1 DESC;</p></td></tr></table><h2><strong>10.2 Revenue This Month</strong></h2><table><tr><td><p>SELECT</p><p>  SUM(amount_inr) / 100.0 AS revenue_inr,</p><p>  COUNT(*) FILTER (WHERE plan_id = 'ind_monthly') AS ind_monthly,</p><p>  COUNT(*) FILTER (WHERE plan_id = 'ind_annual')  AS ind_annual,</p><p>  COUNT(*) FILTER (WHERE plan_id = 'grp_monthly') AS grp_monthly</p><p>FROM payments</p><p>WHERE status = 'success'</p><p>  AND payment_method = 'razorpay'</p><p>  AND created_at &gt;= DATE_TRUNC('month', NOW());</p></td></tr></table><h2><strong>10.3 Active Premium Users</strong></h2><table><tr><td><p>SELECT plan, COUNT(*) as count</p><p>FROM users</p><p>WHERE plan != 'free' AND premium_until &gt; NOW()</p><p>GROUP BY plan;</p></td></tr></table><h2><strong>10.4 Viral Coefficient (Weekly)</strong></h2><table><tr><td><p>-- Referrals created this week</p><p>SELECT</p><p>  COUNT(*) as referrals_created,</p><p>  COUNT(*) FILTER (WHERE status = 'credited') as referrals_converted,</p><p>  ROUND(COUNT(*) FILTER (WHERE status = 'credited')::numeric / NULLIF(COUNT(*), 0) * 100, 1) as conversion_pct</p><p>FROM referrals</p><p>WHERE created_at &gt;= NOW() - INTERVAL '7 days';</p></td></tr></table><h2><strong>10.5 Top 10 Referrers</strong></h2><table><tr><td><p>SELECT u.username, u.telegram_user_id,</p><p>       COUNT(*) as total_referrals,</p><p>       COUNT(*) FILTER (WHERE r.status = 'credited') as credited</p><p>FROM referrals r</p><p>JOIN users u ON u.id = r.referrer_id</p><p>GROUP BY u.id, u.username, u.telegram_user_id</p><p>ORDER BY credited DESC LIMIT 10;</p></td></tr></table><h2><strong>10.6 Checks Nearing Daily Limit (Free Users)</strong></h2><table><tr><td><p>-- Free users who have used 2 of 3 checks today (prime paywall moment)</p><p>SELECT u.telegram_user_id, COUNT(*) as checks_today</p><p>FROM checks c</p><p>JOIN users u ON u.id = c.user_id</p><p>WHERE u.plan = 'free'</p><p>  AND c.created_at &gt;= DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Kolkata') AT TIME ZONE 'Asia/Kolkata'</p><p>GROUP BY u.telegram_user_id</p><p>HAVING COUNT(*) = 2;</p></td></tr></table><h2><strong>10.7 Cache Hit Rate</strong></h2><table><tr><td><p>SELECT</p><p>  COUNT(*) FILTER (WHERE cached = TRUE) as cache_hits,</p><p>  COUNT(*) FILTER (WHERE cached = FALSE) as cache_misses,</p><p>  ROUND(COUNT(*) FILTER (WHERE cached = TRUE)::numeric / COUNT(*) * 100, 1) as hit_rate_pct</p><p>FROM checks</p><p>WHERE created_at &gt;= NOW() - INTERVAL '7 days';</p></td></tr></table><h2><strong>10.8 Unreviewed Abuse Flags</strong></h2><table><tr><td><p>SELECT flag_type, COUNT(*) as count, MIN(created_at) as oldest</p><p>FROM abuse_flags</p><p>WHERE reviewed = FALSE</p><p>GROUP BY flag_type</p><p>ORDER BY count DESC;</p></td></tr></table><table><tr><td><p><strong>üìå Document Status</strong></p><p>Document 10 of 13 ‚Äî COMPLETE</p><p>Next: Document 11 ‚Äî TMA (Telegram Mini App) Specification</p><p>(screen-by-screen UI spec, API endpoints the TMA calls, state management,</p><p>and the Razorpay checkout integration from the TMA side)</p><p>How to deploy this schema:</p><p>  1. Open Supabase ‚Üí SQL Editor</p><p>  2. Run each CREATE TABLE block in order (Section 2‚Äì7)</p><p>  3. Run the indexes block (Section 8)</p><p>  4. Run the RLS policies block (Section 9)</p><p>  5. Verify in Supabase ‚Üí Table Editor that all 7 tables exist</p><p>  6. Test RLS with a dummy user JWT to confirm policies work</p></td></tr></table>