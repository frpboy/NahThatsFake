<p><strong>ğŸ” Nah That's Fake</strong></p><p>Security &amp; Ethics</p><p>Document 7 of 13</p><p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p><p><strong>Document: </strong>Document 7 of 13 â€” Security &amp; Ethics</p><p><strong>Version: </strong>v1.0 â€” MVP</p><p><strong>Date: </strong>February 2026</p><p><strong>Status: </strong>Draft â€” For Developer &amp; Founder Reference</p><p><strong>Bot Handle: </strong>@NahThatsFakeBot</p><table><tr><td><p><strong>ğŸ›¡ï¸ What This Document Covers</strong></p><p>The complete security and ethical operating framework for Nah That's Fake.</p><p>Covers: threat model and attack surface, infrastructure security checklist, API key</p><p>management, database security (Supabase RLS), abuse detection and prevention,</p><p>bot security hardening, ethical principles for running a detection tool, bias and</p><p>fairness considerations, responsible disclosure, and incident response plan.</p></td></tr></table><h1><strong>1. Why Security &amp; Ethics Matter for This Product Specifically</strong></h1><p>Most apps need good security. Nah That's Fake needs exceptional security and careful ethics â€” for reasons specific to what it does.</p><h2><strong>1.1 The Unique Risks of Running a Detection Tool</strong></h2><table><tr><td><p><strong>âš ï¸ Three Unique Risk Categories</strong></p><p>RISK 1 â€” WEAPONISATION</p><p>The bot's output can be weaponised. If someone wants to defame a person, they could</p><p>submit an authentic image and hope for a false positive â€” then screenshot the 'FAKE' result</p><p>and spread it. Our probability language and disclaimers are the first line of defence.</p><p>Our second line: we never say 'FAKE' â€” only '87% likely AI-generated'.</p><p>RISK 2 â€” DATA SENSITIVITY</p><p>Users send us images they suspect are sensitive â€” political figures, private individuals,</p><p>alleged crimes. We must handle these with extreme care. Our zero-storage policy for images</p><p>is not just a privacy feature â€” it's a liability protection.</p><p>RISK 3 â€” TRUST DEPENDENCY</p><p>If users trust the bot too much and stop thinking critically, we've made the problem worse.</p><p>The disclaimer on every result and our probabilistic language are not legal boilerplate â€”</p><p>they are ethical design decisions that keep humans in the loop.</p></td></tr></table><h2><strong>1.2 The Security Threat Model</strong></h2><p>These are the realistic attack vectors for a Telegram bot at MVP scale. We address each in the sections below.</p><table><tr><td><p><strong>Threat</strong></p></td><td><p><strong>Likelihood</strong></p></td><td><p><strong>Impact</strong></p></td><td><p><strong>Primary Mitigation</strong></p></td></tr></table><table><tr><td><p><strong>API key theft from source code</strong></p></td><td><p>ğŸ”´ High</p></td><td><p>ğŸ’€ Critical</p></td><td><p>Env vars only. Never commit keys. GitHub secret scanning.</p></td></tr></table><table><tr><td><p><strong>API cost attack (mass spam checks)</strong></p></td><td><p>ğŸŸ¡ Medium</p></td><td><p>ğŸ’¸ High</p></td><td><p>Rate limiting: 50 checks/hour max per user. Bot anti-abuse rules.</p></td></tr></table><table><tr><td><p><strong>Webhook spoofing (fake payments)</strong></p></td><td><p>ğŸŸ¡ Medium</p></td><td><p>ğŸ’¸ High</p></td><td><p>Always verify Razorpay/Stars signatures before activating premium.</p></td></tr></table><table><tr><td><p><strong>Database breach (Supabase)</strong></p></td><td><p>ğŸŸ  Low</p></td><td><p>ğŸ˜° High</p></td><td><p>RLS policies. No PII stored. Images never saved. Hashes only.</p></td></tr></table><table><tr><td><p><strong>Referral credit farming</strong></p></td><td><p>ğŸ”´ High</p></td><td><p>ğŸ’¸ Medium</p></td><td><p>Anti-abuse rules from Doc 1. Account age checks. Device fingerprint.</p></td></tr></table><table><tr><td><p><strong>Telegram bot token compromise</strong></p></td><td><p>ğŸ”´ High</p></td><td><p>ğŸ’€ Critical</p></td><td><p>Token in env var. Rotate immediately if exposed. Webhook only.</p></td></tr></table><table><tr><td><p><strong>False positive weaponisation</strong></p></td><td><p>ğŸŸ¡ Medium</p></td><td><p>ğŸ˜° High</p></td><td><p>Probability language. Disclaimer on every result. No 'FAKE' verdict.</p></td></tr></table><table><tr><td><p><strong>SSRF via URL submission</strong></p></td><td><p>ğŸŸ  Low</p></td><td><p>ğŸ˜° Medium</p></td><td><p>Never fetch URLs server-side directly. Use VirusTotal API only.</p></td></tr></table><table><tr><td><p><strong>Injection via malformed image</strong></p></td><td><p>ğŸŸ  Low</p></td><td><p>ğŸ˜° Medium</p></td><td><p>Use Pillow/Sightengine SDK â€” never exec or shell out. Validate MIME.</p></td></tr></table><h1><strong>2. Infrastructure Security</strong></h1><h2><strong>2.1 Environment Variables â€” Non-Negotiable Rules</strong></h2><table><tr><td><p><strong>ğŸ”‘ The Golden Rules for Secrets</strong></p><p>1. NEVER hardcode any key, token, or secret in source code â€” ever. Not even in comments.</p><p>2. NEVER commit a .env file to Git. Add .env to .gitignore before your first commit.</p><p>3. Store all secrets as environment variables in Railway/Render dashboard.</p><p>4. Use different keys for development and production â€” always.</p><p>5. Rotate any key that is accidentally exposed immediately â€” assume it is compromised.</p><p>6. Audit your GitHub repo with: git log --all --full-history -- '*.env' to check history.</p></td></tr></table><h2><strong>2.2 Required Environment Variables</strong></h2><table><tr><td><p># Telegram</p><p>TELEGRAM_BOT_TOKEN=your_bot_token_here</p><p>TELEGRAM_WEBHOOK_SECRET=random_32_char_string_you_generate</p><p># Detection APIs</p><p>SIGHTENGINE_API_USER=your_api_user</p><p>SIGHTENGINE_API_SECRET=your_api_secret</p><p>GOOGLE_SAFE_BROWSING_API_KEY=your_key</p><p>VIRUSTOTAL_API_KEY=your_key</p><p># Database</p><p>SUPABASE_URL=https://yourproject.supabase.co</p><p>SUPABASE_SERVICE_ROLE_KEY=your_service_role_key  # NEVER expose client-side</p><p>SUPABASE_ANON_KEY=your_anon_key  # Safe for TMA client use</p><p># Payments</p><p>RAZORPAY_KEY_ID=rzp_live_xxxx</p><p>RAZORPAY_KEY_SECRET=your_secret</p><p>RAZORPAY_WEBHOOK_SECRET=your_webhook_secret</p><p># App</p><p>ENVIRONMENT=production  # or development</p><p>ADMIN_TELEGRAM_ID=your_personal_telegram_id  # for error alerts</p></td></tr></table><h2><strong>2.3 Webhook Security</strong></h2><p>The bot must use webhooks, not polling. Webhooks are more secure and efficient. But they introduce a new attack surface â€” anyone can POST to your webhook URL. You must validate every request.</p><table><tr><td><p># Secure webhook setup â€” validate Telegram's secret token</p><p>from fastapi import Request, HTTPException</p><p>import hmac, hashlib</p><p>WEBHOOK_SECRET = os.environ['TELEGRAM_WEBHOOK_SECRET']</p><p>async def verify_telegram_webhook(request: Request):</p><p>    token = request.headers.get('X-Telegram-Bot-Api-Secret-Token')</p><p>    if not token or not hmac.compare_digest(token, WEBHOOK_SECRET):</p><p>        raise HTTPException(status_code=401, detail='Unauthorized')</p><p># Set webhook with secret token:</p><p># bot.set_webhook(url=WEBHOOK_URL, secret_token=WEBHOOK_SECRET)</p><p># Railway / Render: ensure your webhook URL is HTTPS only.</p><p># Telegram requires HTTPS for webhooks â€” no exceptions.</p></td></tr></table><h2><strong>2.4 Server Hardening Checklist</strong></h2><table><thead><tr><th><p><strong>Item</strong></p></th><th><p><strong>How to Implement</strong></p></th><th><p><strong>Priority</strong></p></th></tr></thead><tbody><tr><td><p>HTTPS only</p></td><td><p>Railway/Render provides this automatically. Never use HTTP.</p></td><td><p>ğŸ”´ Critical</p></td></tr><tr><td><p>Health check endpoint</p></td><td><p>GET /health returns 200. No sensitive info in response.</p></td><td><p>ğŸŸ¡ Important</p></td></tr><tr><td><p>Error responses</p></td><td><p>Never expose stack traces or internal errors to users. Log them, show generic message.</p></td><td><p>ğŸ”´ Critical</p></td></tr><tr><td><p>Request size limits</p></td><td><p>Reject images &gt; 20MB. Reject requests &gt; 50MB. Prevents memory attacks.</p></td><td><p>ğŸŸ¡ Important</p></td></tr><tr><td><p>Timeout all external calls</p></td><td><p>Set 8-second timeout on all API calls. Never let a hung call block the server.</p></td><td><p>ğŸŸ¡ Important</p></td></tr><tr><td><p>Dependency scanning</p></td><td><p>Run pip audit weekly. Keep all packages updated.</p></td><td><p>ğŸŸ  Recommended</p></td></tr><tr><td><p>Logging</p></td><td><p>Log all errors to Sentry (free tier). Log all payments. Never log image data.</p></td><td><p>ğŸŸ¡ Important</p></td></tr><tr><td><p>Rate limiting at server level</p></td><td><p>Use slowapi (Python) â€” 100 requests/min per IP at the server level.</p></td><td><p>ğŸŸ¡ Important</p></td></tr></tbody></table><h1><strong>3. Database Security (Supabase)</strong></h1><p>Supabase uses PostgreSQL with Row Level Security (RLS). RLS is the most important security feature in the entire stack â€” it ensures users can only ever read and write their own data, even if there is a bug in your application code.</p><h2><strong>3.1 Row Level Security â€” Enable on Every Table</strong></h2><table><tr><td><p>-- Enable RLS on all tables (run in Supabase SQL editor)</p><p>ALTER TABLE users ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE checks ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE payments ENABLE ROW LEVEL SECURITY;</p><p>ALTER TABLE referrals ENABLE ROW LEVEL SECURITY;</p><p>-- Users can only read their own row</p><p>CREATE POLICY 'users_read_own' ON users</p><p>  FOR SELECT USING (auth.uid()::text = telegram_user_id);</p><p>-- Users can only read their own checks</p><p>CREATE POLICY 'checks_read_own' ON checks</p><p>  FOR SELECT USING (auth.uid()::text = user_id);</p><p>-- Users can only read their own payments</p><p>CREATE POLICY 'payments_read_own' ON payments</p><p>  FOR SELECT USING (auth.uid()::text = user_id);</p><p>-- IMPORTANT: Backend (service_role key) bypasses RLS.</p><p>-- Only use service_role key on the SERVER â€” never in TMA client code.</p><p>-- TMA client uses anon_key + JWT â€” RLS enforced automatically.</p></td></tr></table><h2><strong>3.2 What Is Never Stored</strong></h2><table><tr><td><p><strong>ğŸš« Zero-Storage Policy â€” Enforced in Code</strong></p><p>The following data is NEVER written to any database or file system:</p><p>  âœ— Image files submitted for checking (processed in memory only)</p><p>  âœ— Raw URLs submitted for checking (only normalised hash stored)</p><p>  âœ— User's phone number (never received from Telegram API)</p><p>  âœ— User's IP address (never logged)</p><p>  âœ— Payment card details (handled entirely by Razorpay)</p><p>  âœ— The content of Telegram messages (only the media/URL is processed)</p><p>Code review checklist: search your codebase for open(), write(), INSERT statements</p><p>that touch image data. There should be zero results.</p></td></tr></table><h2><strong>3.3 Supabase Security Settings</strong></h2><table><thead><tr><th><p><strong>Setting</strong></p></th><th><p><strong>Value</strong></p></th><th><p><strong>Where to Set</strong></p></th></tr></thead><tbody><tr><td><p>Email auth</p></td><td><p>Disabled (we use Telegram auth only)</p></td><td><p>Supabase â†’ Auth â†’ Providers</p></td></tr><tr><td><p>Phone auth</p></td><td><p>Disabled</p></td><td><p>Supabase â†’ Auth â†’ Providers</p></td></tr><tr><td><p>JWT expiry</p></td><td><p>3600 seconds (1 hour)</p></td><td><p>Supabase â†’ Auth â†’ Settings</p></td></tr><tr><td><p>Service role key</p></td><td><p>Server-side only. Never in TMA.</p></td><td><p>Code review enforcement</p></td></tr><tr><td><p>Database backups</p></td><td><p>Enable daily backups (Supabase Pro) or export weekly</p></td><td><p>Supabase â†’ Database</p></td></tr><tr><td><p>Realtime</p></td><td><p>Disabled for all tables (not needed)</p></td><td><p>Supabase â†’ Database â†’ Replication</p></td></tr><tr><td><p>Database password</p></td><td><p>Auto-generated â€” never change to simple password</p></td><td><p>Supabase â†’ Settings</p></td></tr></tbody></table><h1><strong>4. Abuse Detection &amp; Prevention</strong></h1><p>The most likely attacks at MVP scale are not sophisticated hacks â€” they are economic attacks: people trying to get unlimited free checks or inflate referral credits. Here is the full defence system.</p><h2><strong>4.1 Rate Limiting Rules (Full Specification)</strong></h2><table><thead><tr><th><p><strong>Rule</strong></p></th><th><p><strong>Threshold</strong></p></th><th><p><strong>Action</strong></p></th><th><p><strong>Reset</strong></p></th></tr></thead><tbody><tr><td><p>Per-user check rate</p></td><td><p>&gt; 50 checks / 60 min</p></td><td><p>Throttle to 1 check / 10 min. Flag account.</p></td><td><p>Manual review</p></td></tr><tr><td><p>Per-user daily limit</p></td><td><p>&gt; 3 checks / day (free)</p></td><td><p>Show paywall. No check performed.</p></td><td><p>Midnight IST</p></td></tr><tr><td><p>Per-group daily limit</p></td><td><p>&gt; 10 checks / day (free)</p></td><td><p>Show upgrade message in group.</p></td><td><p>Midnight IST</p></td></tr><tr><td><p>Referral redemptions</p></td><td><p>&gt; 5 failed / day</p></td><td><p>Block referral for 24h. Flag account.</p></td><td><p>24 hours</p></td></tr><tr><td><p>New account referrals</p></td><td><p>Account &lt; 24h old</p></td><td><p>Hold credits. Release after 24h confirmed.</p></td><td><p>Automatic</p></td></tr><tr><td><p>Server-level rate limit</p></td><td><p>&gt; 100 requests / min / IP</p></td><td><p>429 Too Many Requests. Log IP.</p></td><td><p>1 minute</p></td></tr><tr><td><p>Payment attempts</p></td><td><p>&gt; 5 failed / hour</p></td><td><p>Block payment for 1 hour. Log.</p></td><td><p>1 hour</p></td></tr><tr><td><p>Group auto-scan alerts</p></td><td><p>&gt; 100 alerts / day / group</p></td><td><p>Suppress further alerts. Admin notified.</p></td><td><p>Midnight IST</p></td></tr></tbody></table><h2><strong>4.2 Abuse Detection Code Pattern</strong></h2><table><tr><td><p>async def check_rate_limit(user_id: str, action: str) -&gt; bool:</p><p>    &quot;&quot;&quot;Returns True if allowed, False if rate limited.&quot;&quot;&quot;</p><p>    key = f'ratelimit:{action}:{user_id}'</p><p>    # Use Supabase or Redis for distributed rate limiting</p><p>    # Simple implementation with Supabase:</p><p>    count = await db.count_recent_actions(user_id, action, window_minutes=60)</p><p>    limits = {</p><p>        'check': 50,        # 50 checks per 60 min</p><p>        'referral': 5,      # 5 referral attempts per 60 min</p><p>        'payment': 5,       # 5 payment attempts per 60 min</p><p>    }</p><p>    if count &gt;= limits.get(action, 100):</p><p>        await flag_account(user_id, reason=f'rate_limit_{action}')</p><p>        return False</p><p>    return True</p><p># Always check BEFORE performing any action:</p><p>if not await check_rate_limit(user_id, 'check'):</p><p>    await message.reply('Slow down! Too many checks at once. Try again in a few minutes.')</p><p>    return</p></td></tr></table><h2><strong>4.3 Flagged Account Handling</strong></h2><table><thead><tr><th><p><strong>Flag Type</strong></p></th><th><p><strong>Automatic Action</strong></p></th><th><p><strong>Manual Review Required?</strong></p></th></tr></thead><tbody><tr><td><p>Rate limit exceeded</p></td><td><p>Throttle for session</p></td><td><p>No â€” automatic</p></td></tr><tr><td><p>Referral farming detected</p></td><td><p>Hold credits + block referral 24h</p></td><td><p>Yes â€” review within 48h</p></td></tr><tr><td><p>Chargeback initiated</p></td><td><p>Suspend premium. Block future purchases.</p></td><td><p>Yes â€” review within 24h</p></td></tr><tr><td><p>High-volume API abuse</p></td><td><p>Throttle + alert admin via Telegram DM</p></td><td><p>Yes â€” review within 4h</p></td></tr><tr><td><p>Multiple account detection</p></td><td><p>Flag both accounts. Hold credits.</p></td><td><p>Yes â€” review within 48h</p></td></tr><tr><td><p>Webhook signature failure</p></td><td><p>Reject request. Log IP. Alert admin.</p></td><td><p>Yes â€” if repeated</p></td></tr></tbody></table><h2><strong>4.4 Admin Alert System</strong></h2><p>Critical security events must alert you immediately. Set up a private Telegram channel or personal DM for alerts.</p><table><tr><td><p>async def send_admin_alert(event_type: str, details: dict):</p><p>    &quot;&quot;&quot;Send security alert to admin's Telegram.&quot;&quot;&quot;</p><p>    admin_id = os.environ['ADMIN_TELEGRAM_ID']</p><p>    message = (</p><p>        f'ğŸš¨ SECURITY ALERT: {event_type}\n'</p><p>        f'Time: {datetime.utcnow().isoformat()}\n'</p><p>        f'Details: {json.dumps(details, indent=2)}'</p><p>    )</p><p>    await bot.send_message(chat_id=admin_id, text=message)</p><p># Trigger on:</p><p># - Webhook signature failure</p><p># - High-volume abuse detected (&gt;50 checks/hr)</p><p># - Payment webhook with invalid signature</p><p># - API key invalid response (possible key compromise)</p><p># - Database connection failure</p><p># - &gt;10 chargeback attempts in 24h</p></td></tr></table><h1><strong>5. Bot Security Hardening</strong></h1><h2><strong>5.1 Input Validation â€” Every Message Type</strong></h2><table><thead><tr><th><p><strong>Input Type</strong></p></th><th><p><strong>Validation Required</strong></p></th><th><p><strong>Reject Condition</strong></p></th></tr></thead><tbody><tr><td><p>Image (photo)</p></td><td><p>Check MIME type. Check file size.</p></td><td><p>Not image MIME / &gt; 20MB / Telegram fetch fails</p></td></tr><tr><td><p>Image (document)</p></td><td><p>Check extension + MIME. Sightengine validates.</p></td><td><p>Non-image extension / &gt; 20MB</p></td></tr><tr><td><p>URL / Link</p></td><td><p>Regex validation. Must start http:// or https://</p></td><td><p>Malformed URL / localhost / private IP ranges</p></td></tr><tr><td><p>Command</p></td><td><p>Match against allowed command list only.</p></td><td><p>Unknown command â†’ friendly 'I don't know that one'</p></td></tr><tr><td><p>Text (no media)</p></td><td><p>Check if contains URL (regex). Otherwise prompt.</p></td><td><p>No URL found â†’ 'Send me an image or link'</p></td></tr><tr><td><p>Forwarded message</p></td><td><p>Process the media/URL inside it. Ignore sender info.</p></td><td><p>No media/URL â†’ prompt</p></td></tr></tbody></table><h2><strong>5.2 SSRF Prevention</strong></h2><p>Server-Side Request Forgery (SSRF) is a risk when your server fetches URLs submitted by users. If someone submits http://169.254.169.254/ (AWS metadata endpoint), your server should not fetch it.</p><table><tr><td><p>import ipaddress, socket</p><p>from urllib.parse import urlparse</p><p>BLOCKED_IP_RANGES = [</p><p>    ipaddress.ip_network('10.0.0.0/8'),       # Private</p><p>    ipaddress.ip_network('172.16.0.0/12'),    # Private</p><p>    ipaddress.ip_network('192.168.0.0/16'),   # Private</p><p>    ipaddress.ip_network('127.0.0.0/8'),      # Loopback</p><p>    ipaddress.ip_network('169.254.0.0/16'),   # AWS metadata</p><p>    ipaddress.ip_network('::1/128'),           # IPv6 loopback</p><p>]</p><p>def is_safe_url(url: str) -&gt; bool:</p><p>    parsed = urlparse(url)</p><p>    if parsed.scheme not in ('http', 'https'):</p><p>        return False</p><p>    try:</p><p>        ip = ipaddress.ip_address(socket.gethostbyname(parsed.hostname))</p><p>        for blocked in BLOCKED_IP_RANGES:</p><p>            if ip in blocked:</p><p>                return False</p><p>    except Exception:</p><p>        return False  # Can't resolve = reject</p><p>    return True</p><p># IMPORTANT: We don't fetch URLs ourselves â€” we pass them to VirusTotal.</p><p># But validate anyway in case future features need direct fetch.</p></td></tr></table><h2><strong>5.3 Telegram Bot Token Security</strong></h2><ul><li>Store token only in environment variable TELEGRAM_BOT_TOKEN â€” never anywhere else.</li><li>Use webhook mode, not polling â€” polling exposes the token in repeated API calls.</li><li>If token is ever accidentally committed to Git: immediately revoke via @BotFather â†’ /revoke, generate new token, update all deployments.</li><li>Set allowed updates in webhook: only receive message, callback_query, pre_checkout_query, successful_payment â€” reject all others.</li><li>Never log the full token. If logging for debug, log only the first 10 characters.</li></ul><h1><strong>6. Ethical Principles</strong></h1><p>Nah That's Fake operates in a sensitive space â€” content authenticity detection. These principles are not marketing copy. They are operational commitments that must guide every product decision.</p><h2><strong>6.1 The Core Ethical Commitments</strong></h2><table><tr><td><p><strong>Principle 1 â€” Humans Stay in the Loop</strong></p><p>NahThatsFake is a tool to assist human judgement, never to replace it.</p><p>Every result includes probability language and a disclaimer. The bot never uses the word 'FAKE'</p><p>as a final verdict â€” only as a probability estimate.</p><p>Design decision: the disclaimer is not optional, cannot be disabled, and is always visible.</p></td></tr></table><table><tr><td><p><strong>Principle 2 â€” Privacy by Design</strong></p><p>We collect the minimum data necessary. We store no images. We store no raw URLs.</p><p>We cannot surveil users â€” by design. This is not just a legal requirement; it is an ethical one.</p><p>Design decision: zero-storage policy for media is enforced in code, not just policy.</p></td></tr></table><table><tr><td><p><strong>Principle 3 â€” No Weaponisation</strong></p><p>We actively monitor for and prevent the bot being used to harass, defame, or harm individuals.</p><p>If a user is consistently submitting images of the same person, that is a red flag for targeted</p><p>harassment. Rate limiting and abuse detection serve an ethical function, not just a cost function.</p><p>Design decision: abuse flags are reviewed by a human (you), not just auto-blocked.</p></td></tr></table><table><tr><td><p><strong>Principle 4 â€” Transparent About Limitations</strong></p><p>We never overstate our accuracy. We never claim to be infallible.</p><p>When we don't know (MEDIUM risk), we say so clearly. We do not dress up uncertainty as confidence.</p><p>Design decision: MEDIUM RISK results explicitly say 'we're not fully sure.'</p></td></tr></table><table><tr><td><p><strong>Principle 5 â€” No Bias Amplification</strong></p><p>AI detection models can carry biases â€” for example, detecting certain ethnicities, skin tones, or</p><p>cultural image styles as 'more likely AI-generated' due to underrepresentation in training data.</p><p>We cannot fix Sightengine's training data. But we can: (a) monitor for patterns in false positives</p><p>across demographic categories, (b) add caveats when checking images of people, (c) never use</p><p>the tool for identity verification or high-stakes decisions about individuals.</p><p>Design decision: if bias patterns emerge in user complaints, escalate to API provider and</p><p>consider switching providers or adding a manual review layer.</p></td></tr></table><table><tr><td><p><strong>Principle 6 â€” No Political Bias in Results</strong></p><p>The bot must not produce systematically different results for content involving different political</p><p>figures, parties, or ideologies. Detection is based on AI probability â€” not editorial judgement.</p><p>Design decision: we do not curate, filter, or adjust results based on the identity of people</p><p>shown in images. The score is the score.</p></td></tr></table><h2><strong>6.2 Sensitive Content Handling</strong></h2><table><thead><tr><th><p><strong>Sensitive Category</strong></p></th><th><p><strong>How We Handle It</strong></p></th></tr></thead><tbody><tr><td><p>Images of minors</p></td><td><p>If a submitted image appears to contain a minor in a potentially harmful context: do not process. Return error. Log for review. Do not store. Report to NCMEC if CSAM suspected.</p></td></tr><tr><td><p>Images of private individuals (non-public)</p></td><td><p>Process normally â€” user is checking if image is fake. But: never confirm or deny the identity of private individuals in our output.</p></td></tr><tr><td><p>Political deepfakes</p></td><td><p>Process normally â€” this is a core use case. Result is probabilistic. Disclaimer always shown.</p></td></tr><tr><td><p>Medical or sensitive imagery</p></td><td><p>Process normally â€” technical detection only. We make no medical claims.</p></td></tr><tr><td><p>Content claimed to show violence or crimes</p></td><td><p>Process for AI detection only. Do not store. If clearly illegal, log for review.</p></td></tr></tbody></table><h2><strong>6.3 Bias Monitoring Protocol</strong></h2><ul><li>Monthly: sample 50 random MEDIUM and HIGH RISK results. Review for patterns in false positives.</li><li>Quarterly: reach out to 5 users who complained about incorrect results. Understand the pattern.</li><li>If a bias pattern is confirmed: add a warning to results in that category. Inform users of the limitation.</li><li>If the bias is severe and systematic: consider pausing the feature until the API provider addresses it.</li></ul><h1><strong>7. Responsible Disclosure &amp; Incident Response</strong></h1><h2><strong>7.1 Responsible Disclosure Policy</strong></h2><p>If a security researcher finds a vulnerability in Nah That's Fake, they should be able to report it safely. Publish this policy before launch.</p><table><tr><td><p><strong>ğŸ“¢ Responsible Disclosure Policy (Publish at /security or in bot /legal)</strong></p><p>We take security seriously. If you discover a vulnerability in Nah That's Fake:</p><p>1. Email us at: security@[yourdomain].com (create this alias before launch)</p><p>2. Include: description of the vulnerability, steps to reproduce, potential impact</p><p>3. Do NOT publicly disclose before giving us 30 days to respond and fix</p><p>4. Do NOT access or modify other users' data while investigating</p><p>What we promise:</p><p>  â€¢ We will acknowledge your report within 48 hours</p><p>  â€¢ We will keep you updated on our progress</p><p>  â€¢ We will not take legal action against good-faith researchers</p><p>  â€¢ For significant findings, we will credit you (with permission) in our changelog</p><p>Out of scope: social engineering, physical attacks, DoS/DDoS attacks.</p></td></tr></table><h2><strong>7.2 Incident Response Plan</strong></h2><p>When something goes wrong â€” and it will â€” here is the response playbook.</p><table><thead><tr><th><p><strong>Incident Type</strong></p></th><th><p><strong>Severity</strong></p></th><th><p><strong>Response Time</strong></p></th><th><p><strong>Steps</strong></p></th></tr></thead><tbody><tr><td><p>API key exposed in public repo</p></td><td><p>ğŸ”´ Critical</p></td><td><p>&lt; 15 min</p></td><td><p>1. Revoke key immediately. 2. Generate new key. 3. Update env vars. 4. Audit what was accessed. 5. Check for abuse.</p></td></tr><tr><td><p>Bot token compromised</p></td><td><p>ğŸ”´ Critical</p></td><td><p>&lt; 15 min</p></td><td><p>1. Revoke via @BotFather immediately. 2. New token. 3. Redeploy. 4. Check for fraudulent activity.</p></td></tr><tr><td><p>Supabase data breach</p></td><td><p>ğŸ”´ Critical</p></td><td><p>&lt; 1 hour</p></td><td><p>1. Revoke all API keys. 2. Assess what data was accessed. 3. Notify affected users. 4. File CERT-In report within 72h.</p></td></tr><tr><td><p>Fraudulent premium activations</p></td><td><p>ğŸŸ¡ Medium</p></td><td><p>&lt; 4 hours</p></td><td><p>1. Identify affected payment IDs. 2. Deactivate fraudulent accounts. 3. Contact Razorpay. 4. Review webhook security.</p></td></tr><tr><td><p>Mass false positive incident</p></td><td><p>ğŸŸ¡ Medium</p></td><td><p>&lt; 4 hours</p></td><td><p>1. Identify affected check IDs. 2. Post notice in bot. 3. Offer affected users credit refund. 4. Investigate root cause.</p></td></tr><tr><td><p>Bot goes offline</p></td><td><p>ğŸŸ  Low</p></td><td><p>&lt; 1 hour</p></td><td><p>1. Check Railway/Render dashboard. 2. Check error logs in Sentry. 3. Redeploy if needed. 4. Check API dependencies.</p></td></tr></tbody></table><h2><strong>7.3 India-Specific Compliance â€” CERT-In</strong></h2><table><tr><td><p><strong>ğŸ‡®ğŸ‡³ CERT-In Reporting Requirements</strong></p><p>The Indian Computer Emergency Response Team (CERT-In) requires mandatory reporting of</p><p>certain cybersecurity incidents within 6 hours of detection (for critical infrastructure)</p><p>or 72 hours for other incidents under the CERT-In Directions 2022.</p><p>As an MVP-stage product you are unlikely to be classified as critical infrastructure,</p><p>but you should be aware of the rules:</p><p>Report to CERT-In if: data breach affecting &gt;500 users, ransomware attack,</p><p>unauthorised access to your systems.</p><p>Report portal: https://www.cert-in.org.in/</p><p>Consult a lawyer before filing â€” incorrect filings can cause issues.</p></td></tr></table><table><tr><td><p><strong>ğŸ“Œ Document Status</strong></p><p>Document 7 of 13 â€” COMPLETE</p><p>Next: Document 8 â€” Telegram Commands (full command specification, handler logic,</p><p>group vs private behaviour, admin commands, and command response copy)</p><p>Security actions to take immediately before launch:</p><p>  1. Set up all environment variables in Railway/Render dashboard.</p><p>  2. Enable RLS on all Supabase tables using the SQL from Section 3.</p><p>  3. Set up Sentry free tier for error logging.</p><p>  4. Create security@[yourdomain].com email alias.</p><p>  5. Test webhook signature verification end-to-end.</p><p>  6. Run: git log --all --full-history -- '*.env' to check for accidental commits.</p></td></tr></table>