<p><strong>üîç Nah That's Fake</strong></p><p>API Contracts</p><p>Document 9 of 13</p><p>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</p><p><strong>Document: </strong>Document 9 of 13 ‚Äî API Contracts</p><p><strong>Version: </strong>v1.0 ‚Äî MVP</p><p><strong>Date: </strong>February 2026</p><p><strong>Status: </strong>Draft ‚Äî Primary Reference for Integration Code</p><p><strong>Bot Handle: </strong>@NahThatsFakeBot</p><table><tr><td><p><strong>üîå What This Document Covers</strong></p><p>The exact request and response specifications for every external API used by</p><p>Nah That's Fake. For each API: authentication, endpoints used, request format,</p><p>response format, field mapping to our Trust Score, error handling, and Python</p><p>code samples ready to paste into your AI IDE.</p><p>APIs covered: Sightengine ¬∑ Google Safe Browsing ¬∑ VirusTotal</p><p>              Razorpay ¬∑ Telegram Bot API ¬∑ Supabase</p></td></tr></table><h1><strong>1. API Dependency Map</strong></h1><p>Here is how each API fits into the system and which part of the codebase calls it.</p><table><thead><tr><th><p><strong>API</strong></p></th><th><p><strong>Called By</strong></p></th><th><p><strong>Purpose</strong></p></th><th><p><strong>Replaces If Down</strong></p></th></tr></thead><tbody><tr><td><p>Sightengine</p></td><td><p>Image handler</p></td><td><p>AI/deepfake image detection</p></td><td><p>Queue check, notify user of delay</p></td></tr><tr><td><p>Google Safe Browsing</p></td><td><p>Link handler</p></td><td><p>Phishing &amp; malware URL detection</p></td><td><p>Skip, use VirusTotal only</p></td></tr><tr><td><p>VirusTotal</p></td><td><p>Link handler</p></td><td><p>Multi-vendor URL threat scanning</p></td><td><p>Skip, use Google Safe Browsing only</p></td></tr><tr><td><p>Razorpay</p></td><td><p>Payment handler</p></td><td><p>INR payment processing</p></td><td><p>Telegram Stars only</p></td></tr><tr><td><p>Telegram Bot API</p></td><td><p>All handlers</p></td><td><p>Bot messaging, file download</p></td><td><p>No fallback ‚Äî core dependency</p></td></tr><tr><td><p>Supabase</p></td><td><p>All handlers</p></td><td><p>Database, auth, cache</p></td><td><p>In-memory cache fallback (limited)</p></td></tr></tbody></table><table><tr><td><p><strong>‚è±Ô∏è Timeout Strategy</strong></p><p>Set a timeout on EVERY external API call. A hanging call will block your async handler</p><p>and degrade the experience for all concurrent users.</p><p>Recommended timeouts:</p><p>  Sightengine:           8 seconds  (image upload + analysis)</p><p>  Google Safe Browsing:  5 seconds</p><p>  VirusTotal:            6 seconds</p><p>  Razorpay:              10 seconds (payment operations need more time)</p><p>  Supabase:              5 seconds</p><p>  Telegram Bot API:      10 seconds (file downloads can be slower)</p><p>Pattern: use asyncio.wait_for(coroutine, timeout=N) in Python.</p></td></tr></table><h1><strong>2. Sightengine API</strong></h1><table><tr><td><p><strong>Sightengine ‚Äî AI Image Detection</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://api.sightengine.com/1.0/</p><p><strong>Auth: </strong>Query params: api_user + api_secret</p><p><strong>Rate Limit: </strong>Free: 100 ops/day | Paid: from $29/month</p><p><strong>Cost: </strong>Free tier sufficient for MVP launch</p></td></tr></table><h2><strong>2.1 Endpoint Used</strong></h2><table><tr><td><p>GET https://api.sightengine.com/1.0/check.json</p><p># Required params:</p><p># models=genai    ‚Üí detects AI-generated images</p><p># api_user        ‚Üí from env: SIGHTENGINE_API_USER</p><p># api_secret      ‚Üí from env: SIGHTENGINE_API_SECRET</p></td></tr></table><h2><strong>2.2 Full Request ‚Äî Python</strong></h2><table><tr><td><p>import aiohttp, asyncio</p><p>async def check_image_sightengine(image_bytes: bytes) -&gt; dict:</p><p>    url = 'https://api.sightengine.com/1.0/check.json'</p><p>    </p><p>    # Prepare multipart form data</p><p>    data = aiohttp.FormData()</p><p>    data.add_field('media', image_bytes, filename='image.jpg', content_type='image/jpeg')</p><p>    data.add_field('models', 'genai')  # genai = AI generation detection</p><p>    data.add_field('api_user', os.environ['SIGHTENGINE_API_USER'])</p><p>    data.add_field('api_secret', os.environ['SIGHTENGINE_API_SECRET'])</p><p>    </p><p>    async with aiohttp.ClientSession() as session:</p><p>        async with session.post(url, data=data, timeout=aiohttp.ClientTimeout(total=8)) as resp:</p><p>            if resp.status != 200:</p><p>                raise Exception(f'Sightengine error: {resp.status}')</p><p>            return await resp.json()</p></td></tr></table><h2><strong>2.3 Successful Response</strong></h2><table><tr><td><p>{</p><p>  'status': 'success',</p><p>  'request': {</p><p>    'id': 'req_AbcDef123',</p><p>    'timestamp': 1739500000.0,</p><p>    'operations': 1</p><p>  },</p><p>  'type': {</p><p>    'ai_generated': 0.87,    ‚Üê THE KEY FIELD ‚Äî range 0.0 to 1.0</p><p>    'deepfake': 0.12,</p><p>    'real': 0.01</p><p>  },</p><p>  'media': {</p><p>    'id': 'med_AbcDef',</p><p>    'uri': 'https://...'</p><p>  }</p><p>}</p></td></tr></table><h2><strong>2.4 Field Mapping to Trust Score</strong></h2><table><thead><tr><th><p><strong>Sightengine Field</strong></p></th><th><p><strong>Our Usage</strong></p></th><th><p><strong>Risk Mapping</strong></p></th></tr></thead><tbody><tr><td><p>type.ai_generated</p></td><td><p>PRIMARY ‚Äî this is our Trust Score</p></td><td><p>&gt; 0.80 = HIGH  |  0.40-0.80 = MEDIUM  |  &lt; 0.40 = LOW</p></td></tr><tr><td><p>type.deepfake</p></td><td><p>SECONDARY ‚Äî shown in breakdown if &gt; 0.3</p></td><td><p>Add note: 'Deepfake score: X%' in detail view</p></td></tr><tr><td><p>type.real</p></td><td><p>Not used directly ‚Äî inverse of ai_generated</p></td><td><p>Displayed as '(100 - ai_generated)% likely real'</p></td></tr><tr><td><p>request.operations</p></td><td><p>Track for API quota monitoring</p></td><td><p>Decrement from daily free tier counter</p></td></tr></tbody></table><h2><strong>2.5 Error Responses</strong></h2><table><thead><tr><th><p><strong>HTTP Status</strong></p></th><th><p><strong>Error Meaning</strong></p></th><th><p><strong>Our Handling</strong></p></th></tr></thead><tbody><tr><td><p>400</p></td><td><p>Bad request ‚Äî invalid image format or params</p></td><td><p>Log error. Reply: 'Couldn't read that image format. Try JPG or PNG.'</p></td></tr><tr><td><p>401</p></td><td><p>Invalid API credentials</p></td><td><p>Log + admin alert. Reply: 'Scanner temporarily unavailable.'</p></td></tr><tr><td><p>429</p></td><td><p>Rate limit exceeded</p></td><td><p>Queue the check. Notify user: 'Queued ‚Äî result in ~2 min.'</p></td></tr><tr><td><p>500</p></td><td><p>Sightengine server error</p></td><td><p>Retry once after 2 seconds. If still fails: queue.</p></td></tr><tr><td><p>Timeout (8s)</p></td><td><p>API call hung</p></td><td><p>Retry once. If still hung: queue. Notify user.</p></td></tr></tbody></table><h2><strong>2.6 Complete Integration Function</strong></h2><table><tr><td><p>async def analyse_image(image_bytes: bytes) -&gt; dict:</p><p>    &quot;&quot;&quot;</p><p>    Returns: {</p><p>        'score': float (0.0-1.0),</p><p>        'risk_level': 'HIGH' | 'MEDIUM' | 'LOW',</p><p>        'deepfake_score': float,</p><p>        'cached': bool,</p><p>        'error': str | None</p><p>    }</p><p>    &quot;&quot;&quot;</p><p>    try:</p><p>        result = await asyncio.wait_for(</p><p>            check_image_sightengine(image_bytes),</p><p>            timeout=8.0</p><p>        )</p><p>        score = result['type']['ai_generated']</p><p>        deepfake = result['type'].get('deepfake', 0.0)</p><p>        </p><p>        if score &gt; 0.80:   risk = 'HIGH'</p><p>        elif score &gt; 0.40: risk = 'MEDIUM'</p><p>        else:              risk = 'LOW'</p><p>        </p><p>        return {'score': score, 'risk_level': risk,</p><p>                'deepfake_score': deepfake, 'cached': False, 'error': None}</p><p>    except asyncio.TimeoutError:</p><p>        return {'score': None, 'risk_level': None,</p><p>                'cached': False, 'error': 'timeout'}</p><p>    except Exception as e:</p><p>        logger.error(f'Sightengine error: {e}')</p><p>        return {'score': None, 'risk_level': None,</p><p>                'cached': False, 'error': str(e)}</p></td></tr></table><h1><strong>3. Google Safe Browsing API</strong></h1><table><tr><td><p><strong>Google Safe Browsing ‚Äî URL Threat Detection</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://safebrowsing.googleapis.com/v4/</p><p><strong>Auth: </strong>Query param: key=GOOGLE_SAFE_BROWSING_API_KEY</p><p><strong>Rate Limit: </strong>~10,000 requests/day free</p><p><strong>Cost: </strong>Free ‚Äî no cost at MVP scale</p></td></tr></table><h2><strong>3.1 Endpoint Used</strong></h2><table><tr><td><p>POST https://safebrowsing.googleapis.com/v4/threatMatches:find?key=API_KEY</p><p>Content-Type: application/json</p></td></tr></table><h2><strong>3.2 Request Body</strong></h2><table><tr><td><p>{</p><p>  'client': {</p><p>    'clientId': 'nahthatsfake',</p><p>    'clientVersion': '1.0.0'</p><p>  },</p><p>  'threatInfo': {</p><p>    'threatTypes': [</p><p>      'MALWARE',</p><p>      'SOCIAL_ENGINEERING',</p><p>      'UNWANTED_SOFTWARE',</p><p>      'POTENTIALLY_HARMFUL_APPLICATION'</p><p>    ],</p><p>    'platformTypes': ['ANY_PLATFORM'],</p><p>    'threatEntryTypes': ['URL'],</p><p>    'threatEntries': [</p><p>      {'url': 'https://suspicious-site.example.com'}</p><p>    ]</p><p>  }</p><p>}</p></td></tr></table><h2><strong>3.3 Responses</strong></h2><p><strong>Clean URL (no threats):</strong></p><table><tr><td><p>{}</p><p># Empty body = SAFE. No matches found.</p></td></tr></table><p><strong>Threat found:</strong></p><table><tr><td><p>{</p><p>  'matches': [</p><p>    {</p><p>      'threatType': 'SOCIAL_ENGINEERING',  ‚Üê phishing/deceptive</p><p>      'platformType': 'ANY_PLATFORM',</p><p>      'threatEntryType': 'URL',</p><p>      'threat': {'url': 'https://suspicious-site.example.com'},</p><p>      'cacheDuration': '300s'</p><p>    }</p><p>  ]</p><p>}</p></td></tr></table><h2><strong>3.4 Threat Type Mapping</strong></h2><table><thead><tr><th><p><strong>Google Threat Type</strong></p></th><th><p><strong>Our Risk Level</strong></p></th><th><p><strong>Bot Message Fragment</strong></p></th></tr></thead><tbody><tr><td><p>SOCIAL_ENGINEERING</p></td><td><p>HIGH (override ‚Äî always HIGH)</p></td><td><p>'üö® Confirmed phishing attempt. Do not click.'</p></td></tr><tr><td><p>MALWARE</p></td><td><p>HIGH (override ‚Äî always HIGH)</p></td><td><p>'üö® Malware detected on this site.'</p></td></tr><tr><td><p>UNWANTED_SOFTWARE</p></td><td><p>MEDIUM</p></td><td><p>'‚ö†Ô∏è This site may install unwanted software.'</p></td></tr><tr><td><p>POTENTIALLY_HARMFUL_APPLICATION</p></td><td><p>MEDIUM</p></td><td><p>'‚ö†Ô∏è Potentially harmful app detected.'</p></td></tr><tr><td><p>No matches (empty response)</p></td><td><p>SAFE ‚Äî defer to VirusTotal</p></td><td><p>Continue to VirusTotal check</p></td></tr></tbody></table><h2><strong>3.5 Python Integration</strong></h2><table><tr><td><p>async def check_google_safe_browsing(url: str) -&gt; dict:</p><p>    endpoint = f'https://safebrowsing.googleapis.com/v4/threatMatches:find'</p><p>    params = {'key': os.environ['GOOGLE_SAFE_BROWSING_API_KEY']}</p><p>    payload = {</p><p>        'client': {'clientId': 'nahthatsfake', 'clientVersion': '1.0.0'},</p><p>        'threatInfo': {</p><p>            'threatTypes': ['MALWARE', 'SOCIAL_ENGINEERING',</p><p>                           'UNWANTED_SOFTWARE', 'POTENTIALLY_HARMFUL_APPLICATION'],</p><p>            'platformTypes': ['ANY_PLATFORM'],</p><p>            'threatEntryTypes': ['URL'],</p><p>            'threatEntries': [{'url': url}]</p><p>        }</p><p>    }</p><p>    async with aiohttp.ClientSession() as session:</p><p>        async with session.post(endpoint, params=params, json=payload,</p><p>                               timeout=aiohttp.ClientTimeout(total=5)) as resp:</p><p>            data = await resp.json()</p><p>            matches = data.get('matches', [])</p><p>            if not matches:</p><p>                return {'safe': True, 'threat_type': None}</p><p>            threat = matches[0]['threatType']</p><p>            return {'safe': False, 'threat_type': threat}</p></td></tr></table><h1><strong>4. VirusTotal API</strong></h1><table><tr><td><p><strong>VirusTotal ‚Äî Multi-Vendor URL Scanning</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://www.virustotal.com/api/v3/</p><p><strong>Auth: </strong>Header: x-apikey: VIRUSTOTAL_API_KEY</p><p><strong>Rate Limit: </strong>Free: 4 requests/min, 500 requests/day</p><p><strong>Cost: </strong>Free ‚Äî no cost at MVP scale</p></td></tr></table><h2><strong>4.1 Endpoints Used</strong></h2><table><thead><tr><th><p><strong>Action</strong></p></th><th><p><strong>Method</strong></p></th><th><p><strong>Endpoint</strong></p></th></tr></thead><tbody><tr><td><p>Submit URL for scan</p></td><td><p>POST</p></td><td><p>/urls</p></td></tr><tr><td><p>Get URL analysis</p></td><td><p>GET</p></td><td><p>/urls/{url_id}</p></td></tr><tr><td><p>Get URL report</p></td><td><p>GET</p></td><td><p>/urls/{base64_url}  (preferred ‚Äî instant if cached)</p></td></tr></tbody></table><h2><strong>4.2 Preferred Flow ‚Äî GET Cached Report First</strong></h2><p>VirusTotal caches results for known URLs. Always try GET first before POSTing a new scan ‚Äî it's faster and saves your rate limit quota.</p><table><tr><td><p>import base64</p><p>def url_to_vt_id(url: str) -&gt; str:</p><p>    &quot;&quot;&quot;Convert URL to VirusTotal's base64 ID format.&quot;&quot;&quot;</p><p>    return base64.urlsafe_b64encode(url.encode()).decode().rstrip('=')</p><p>async def check_virustotal(url: str) -&gt; dict:</p><p>    headers = {'x-apikey': os.environ['VIRUSTOTAL_API_KEY']}</p><p>    url_id = url_to_vt_id(url)</p><p>    </p><p>    # Step 1: Try to get cached report</p><p>    async with aiohttp.ClientSession() as session:</p><p>        async with session.get(</p><p>            f'https://www.virustotal.com/api/v3/urls/{url_id}',</p><p>            headers=headers,</p><p>            timeout=aiohttp.ClientTimeout(total=6)</p><p>        ) as resp:</p><p>            if resp.status == 200:</p><p>                data = await resp.json()</p><p>                return parse_vt_response(data)</p><p>            # 404 = not in cache ‚Üí submit for fresh scan</p><p>            elif resp.status == 404:</p><p>                return await submit_vt_url(url, headers)</p><p>            else:</p><p>                raise Exception(f'VT error: {resp.status}')</p></td></tr></table><h2><strong>4.3 Successful Response Structure</strong></h2><table><tr><td><p>{</p><p>  'data': {</p><p>    'id': 'u-abc123...',</p><p>    'type': 'analysis',</p><p>    'attributes': {</p><p>      'last_analysis_stats': {</p><p>        'malicious': 3,       ‚Üê vendors that flagged as malicious</p><p>        'suspicious': 1,      ‚Üê vendors that flagged as suspicious</p><p>        'harmless': 68,       ‚Üê vendors that said clean</p><p>        'undetected': 18,     ‚Üê vendors with no verdict</p><p>        'timeout': 0</p><p>      },</p><p>      'last_analysis_date': 1739500000,</p><p>      'url': 'https://suspicious-site.example.com',</p><p>      'reputation': -5,       ‚Üê negative = bad reputation</p><p>    }</p><p>  }</p><p>}</p></td></tr></table><h2><strong>4.4 Field Mapping to Trust Score</strong></h2><table><thead><tr><th><p><strong>VT Field</strong></p></th><th><p><strong>Our Usage</strong></p></th><th><p><strong>Risk Contribution</strong></p></th></tr></thead><tbody><tr><td><p>malicious + suspicious</p></td><td><p>TOTAL_FLAGS = malicious + suspicious</p></td><td><p>0 = LOW  |  1-2 = MEDIUM  |  3+ = HIGH</p></td></tr><tr><td><p>reputation</p></td><td><p>Supplementary signal</p></td><td><p>&lt; -3: escalate 1 tier if borderline MEDIUM</p></td></tr><tr><td><p>harmless</p></td><td><p>Not used directly</p></td><td><p>Shown in report breakdown for transparency</p></td></tr><tr><td><p>last_analysis_date</p></td><td><p>Cache freshness check</p></td><td><p>If &gt; 7 days old: re-submit for fresh scan</p></td></tr></tbody></table><h2><strong>4.5 Parse Function</strong></h2><table><tr><td><p>def parse_vt_response(data: dict) -&gt; dict:</p><p>    stats = data['data']['attributes']['last_analysis_stats']</p><p>    reputation = data['data']['attributes'].get('reputation', 0)</p><p>    </p><p>    malicious  = stats.get('malicious', 0)</p><p>    suspicious = stats.get('suspicious', 0)</p><p>    total_flags = malicious + suspicious</p><p>    </p><p>    if total_flags &gt;= 3:    risk = 'HIGH'</p><p>    elif total_flags &gt;= 1:  risk = 'MEDIUM'</p><p>    else:                   risk = 'LOW'</p><p>    </p><p>    # Reputation modifier</p><p>    if reputation &lt; -3 and risk == 'LOW':  risk = 'MEDIUM'</p><p>    if reputation &lt; -3 and risk == 'MEDIUM': risk = 'HIGH'</p><p>    </p><p>    return {</p><p>        'total_flags': total_flags,</p><p>        'malicious': malicious,</p><p>        'suspicious': suspicious,</p><p>        'risk_level': risk,</p><p>        'reputation': reputation,</p><p>        'error': None</p><p>    }</p></td></tr></table><h2><strong>4.6 Combining Google Safe Browsing + VirusTotal</strong></h2><table><tr><td><p>async def analyse_url(url: str) -&gt; dict:</p><p>    &quot;&quot;&quot;Run both APIs in parallel and combine results.&quot;&quot;&quot;</p><p>    gsb_task = asyncio.create_task(check_google_safe_browsing(url))</p><p>    vt_task  = asyncio.create_task(check_virustotal(url))</p><p>    </p><p>    gsb_result, vt_result = await asyncio.gather(</p><p>        gsb_task, vt_task, return_exceptions=True</p><p>    )</p><p>    </p><p>    # Handle partial failures gracefully</p><p>    gsb_ok = not isinstance(gsb_result, Exception)</p><p>    vt_ok  = not isinstance(vt_result, Exception)</p><p>    </p><p>    # Google Safe Browsing always overrides to HIGH if it flags</p><p>    if gsb_ok and not gsb_result.get('safe', True):</p><p>        return {'risk_level': 'HIGH', 'source': 'google_safe_browsing',</p><p>                'threat_type': gsb_result['threat_type'],</p><p>                'vt_flags': vt_result.get('total_flags', 0) if vt_ok else 'N/A'}</p><p>    </p><p>    # Otherwise use VirusTotal risk level</p><p>    if vt_ok:</p><p>        return {'risk_level': vt_result['risk_level'],</p><p>                'vt_flags': vt_result['total_flags'],</p><p>                'source': 'virustotal', 'threat_type': None}</p><p>    </p><p>    # Both failed</p><p>    return {'risk_level': None, 'error': 'both_apis_failed'}</p></td></tr></table><h1><strong>5. Razorpay API</strong></h1><table><tr><td><p><strong>Razorpay ‚Äî Payment Processing</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://api.razorpay.com/v1/</p><p><strong>Auth: </strong>HTTP Basic Auth: key_id:key_secret</p><p><strong>Rate Limit: </strong>No rate limit for standard operations</p><p><strong>Cost: </strong>2% per transaction ‚Äî no monthly fee</p></td></tr></table><p>Note: Full Razorpay payment flow is documented in Document 3. This section covers the exact API contracts only.</p><h2><strong>5.1 Create Order</strong></h2><table><tr><td><p>POST https://api.razorpay.com/v1/orders</p><p>Authorization: Basic base64(key_id:key_secret)</p><p>Content-Type: application/json</p><p>Request body:</p><p>{</p><p>  'amount': 9900,          # Amount in PAISE (‚Çπ99 = 9900)</p><p>  'currency': 'INR',</p><p>  'receipt': 'order_[user_id]_[timestamp]',  # Your internal reference</p><p>  'notes': {</p><p>    'plan_id': 'ind_monthly',</p><p>    'user_id': '123456789'</p><p>  }</p><p>}</p></td></tr></table><p><strong>Response:</strong></p><table><tr><td><p>{</p><p>  'id': 'order_AbcDef123',   ‚Üê send this to TMA frontend</p><p>  'entity': 'order',</p><p>  'amount': 9900,</p><p>  'currency': 'INR',</p><p>  'status': 'created',</p><p>  'receipt': 'order_123456789_1739500000',</p><p>  'created_at': 1739500000</p><p>}</p></td></tr></table><h2><strong>5.2 Verify Payment Signature</strong></h2><table><tr><td><p># Called after Razorpay checkout completes on the TMA frontend</p><p># Frontend sends: razorpay_order_id, razorpay_payment_id, razorpay_signature</p><p>import hmac, hashlib</p><p>def verify_payment(order_id: str, payment_id: str, signature: str) -&gt; bool:</p><p>    message = f'{order_id}|{payment_id}'</p><p>    expected = hmac.new(</p><p>        os.environ['RAZORPAY_KEY_SECRET'].encode(),</p><p>        message.encode(),</p><p>        hashlib.sha256</p><p>    ).hexdigest()</p><p>    return hmac.compare_digest(expected, signature)</p><p># POST /api/verify-payment</p><p># If valid: activate premium in Supabase</p><p># If invalid: return 400, log attempt</p></td></tr></table><h2><strong>5.3 Webhook Events</strong></h2><table><thead><tr><th><p><strong>Event</strong></p></th><th><p><strong>Payload Key Fields</strong></p></th><th><p><strong>Our Action</strong></p></th></tr></thead><tbody><tr><td><p>payment.captured</p></td><td><p>payload.payment.entity: {id, amount, order_id, status}</p></td><td><p>Activate premium. Idempotency check first.</p></td></tr><tr><td><p>payment.failed</p></td><td><p>payload.payment.entity: {id, error_code, error_description}</p></td><td><p>Log. Do not activate. No user action needed.</p></td></tr><tr><td><p>refund.created</p></td><td><p>payload.refund.entity: {id, payment_id, amount, status}</p></td><td><p>Deactivate premium if full refund.</p></td></tr></tbody></table><h2><strong>5.4 Webhook Verification</strong></h2><table><tr><td><p># POST /webhooks/razorpay</p><p># Headers: X-Razorpay-Signature: &lt;signature&gt;</p><p>def verify_webhook(payload_bytes: bytes, signature: str) -&gt; bool:</p><p>    expected = hmac.new(</p><p>        os.environ['RAZORPAY_WEBHOOK_SECRET'].encode(),</p><p>        payload_bytes,   # Raw bytes ‚Äî NOT decoded string</p><p>        hashlib.sha256</p><p>    ).hexdigest()</p><p>    return hmac.compare_digest(expected, signature)</p><p># In FastAPI route:</p><p># @app.post('/webhooks/razorpay')</p><p># async def razorpay_webhook(request: Request):</p><p>#     body = await request.body()  # Raw bytes</p><p>#     sig  = request.headers.get('X-Razorpay-Signature')</p><p>#     if not verify_webhook(body, sig): raise HTTPException(401)</p><p>#     event = json.loads(body)</p><p>#     await handle_razorpay_event(event)</p></td></tr></table><h1><strong>6. Telegram Bot API</strong></h1><table><tr><td><p><strong>Telegram Bot API ‚Äî Core Bot Operations</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://api.telegram.org/bot{TOKEN}/</p><p><strong>Auth: </strong>Token in URL path: /bot{TELEGRAM_BOT_TOKEN}/</p><p><strong>Rate Limit: </strong>30 messages/second per bot, 20 per group/min</p><p><strong>Cost: </strong>Free ‚Äî no cost</p></td></tr></table><p>We use python-telegram-bot v20+ (async). This section covers the key methods our code calls directly.</p><h2><strong>6.1 Key Methods Used</strong></h2><table><thead><tr><th><p><strong>Method</strong></p></th><th><p><strong>When Used</strong></p></th><th><p><strong>Key Params</strong></p></th></tr></thead><tbody><tr><td><p>sendMessage</p></td><td><p>All bot replies</p></td><td><p>chat_id, text, parse_mode='HTML', reply_markup</p></td></tr><tr><td><p>getFile + downloadFile</p></td><td><p>Download user-submitted images</p></td><td><p>file_id from message.photo[-1].file_id</p></td></tr><tr><td><p>answerCallbackQuery</p></td><td><p>Acknowledge button press</p></td><td><p>callback_query_id, text (optional popup)</p></td></tr><tr><td><p>answerPreCheckoutQuery</p></td><td><p>Approve Stars payment</p></td><td><p>pre_checkout_query_id, ok=True</p></td></tr><tr><td><p>sendInvoice</p></td><td><p>Initiate Stars payment</p></td><td><p>chat_id, title, description, payload, currency='XTR', prices</p></td></tr><tr><td><p>getChatMember</p></td><td><p>Check if user is group admin</p></td><td><p>chat_id, user_id ‚Äî check status field</p></td></tr><tr><td><p>setWebhook</p></td><td><p>Register webhook URL</p></td><td><p>url, secret_token=WEBHOOK_SECRET, allowed_updates</p></td></tr><tr><td><p>deleteWebhook</p></td><td><p>Remove webhook (switch to polling for debug)</p></td><td><p>drop_pending_updates=True</p></td></tr></tbody></table><h2><strong>6.2 Downloading User Images</strong></h2><table><tr><td><p>async def download_image(message) -&gt; bytes:</p><p>    &quot;&quot;&quot;Download image from Telegram to memory. Never to disk.&quot;&quot;&quot;</p><p>    # Get highest quality photo (last in array = largest)</p><p>    if message.photo:</p><p>        file_id = message.photo[-1].file_id</p><p>    elif message.document and message.document.mime_type.startswith('image/'):</p><p>        file_id = message.document.file_id</p><p>        # Also check file size</p><p>        if message.document.file_size &gt; 20 * 1024 * 1024:  # 20MB</p><p>            raise ValueError('File too large')</p><p>    else:</p><p>        raise ValueError('No image found')</p><p>    </p><p>    file = await bot.get_file(file_id)</p><p>    # Download to BytesIO (in-memory, never touches disk)</p><p>    buffer = io.BytesIO()</p><p>    await file.download_to_memory(buffer)</p><p>    buffer.seek(0)</p><p>    return buffer.read()  # Return raw bytes</p></td></tr></table><h2><strong>6.3 Group Admin Check</strong></h2><table><tr><td><p>async def is_group_admin(bot, chat_id: int, user_id: int) -&gt; bool:</p><p>    &quot;&quot;&quot;Returns True if user is admin or creator of the group.&quot;&quot;&quot;</p><p>    try:</p><p>        member = await bot.get_chat_member(chat_id=chat_id, user_id=user_id)</p><p>        return member.status in ('administrator', 'creator')</p><p>    except Exception:</p><p>        return False  # Can't check = assume not admin</p></td></tr></table><h2><strong>6.4 Allowed Updates (set in setWebhook)</strong></h2><table><tr><td><p>await bot.set_webhook(</p><p>    url=f'https://yourdomain.com/webhook/{WEBHOOK_SECRET}',</p><p>    secret_token=WEBHOOK_SECRET,</p><p>    allowed_updates=[</p><p>        'message',              # All regular messages</p><p>        'callback_query',       # Button presses</p><p>        'pre_checkout_query',   # Stars payment approval</p><p>        'successful_payment',   # Stars payment confirmed</p><p>        'my_chat_member',       # Bot added/removed from groups</p><p>    ]</p><p>    # Omitting other update types = Telegram won't send them = less load</p><p>)</p></td></tr></table><h1><strong>7. Supabase API</strong></h1><table><tr><td><p><strong>Supabase ‚Äî Database &amp; Auth</strong></p></td></tr><tr><td><p><strong>Base URL: </strong>https://{PROJECT_REF}.supabase.co/</p><p><strong>Auth: </strong>Service role key (server) or Anon key + JWT (TMA client)</p><p><strong>Rate Limit: </strong>Free tier: 500MB DB, 2GB bandwidth/month</p><p><strong>Cost: </strong>Free tier sufficient for MVP launch</p></td></tr></table><h2><strong>7.1 Python Client Setup</strong></h2><table><tr><td><p>from supabase import create_client, Client</p><p># Server-side (bot backend) ‚Äî uses service_role key ‚Äî bypasses RLS</p><p>supabase: Client = create_client(</p><p>    os.environ['SUPABASE_URL'],</p><p>    os.environ['SUPABASE_SERVICE_ROLE_KEY']  # Never expose client-side</p><p>)</p><p># TMA client-side ‚Äî uses anon key ‚Äî RLS enforced</p><p># (in JavaScript/React for TMA)</p><p># const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)</p></td></tr></table><h2><strong>7.2 Key Query Patterns</strong></h2><table><tr><td><p># ‚îÄ‚îÄ GET USER ‚îÄ‚îÄ</p><p>user = supabase.table('users').select('*')</p><p>    .eq('telegram_user_id', str(user_id)).single().execute()</p><p># ‚îÄ‚îÄ UPSERT USER (create or update) ‚îÄ‚îÄ</p><p>supabase.table('users').upsert({</p><p>    'telegram_user_id': str(user_id),</p><p>    'username': username,</p><p>    'first_name': first_name,</p><p>    'updated_at': 'now()'</p><p>}, on_conflict='telegram_user_id').execute()</p><p># ‚îÄ‚îÄ COUNT CHECKS TODAY (midnight IST reset) ‚îÄ‚îÄ</p><p>from datetime import datetime, timezone, timedelta</p><p>IST = timezone(timedelta(hours=5, minutes=30))</p><p>midnight_ist = datetime.now(IST).replace(hour=0, minute=0, second=0)</p><p>midnight_utc = midnight_ist.astimezone(timezone.utc).isoformat()</p><p>result = supabase.table('checks')</p><p>    .select('id', count='exact')</p><p>    .eq('user_id', str(user_id))</p><p>    .gte('created_at', midnight_utc)</p><p>    .execute()</p><p>checks_today = result.count</p><p># ‚îÄ‚îÄ INSERT CHECK RECORD ‚îÄ‚îÄ</p><p>supabase.table('checks').insert({</p><p>    'user_id': str(user_id),</p><p>    'check_type': 'image',   # or 'link'</p><p>    'content_hash': sha256_hash,</p><p>    'score': 0.87,</p><p>    'risk_level': 'HIGH',</p><p>    'cached': False,</p><p>    'created_at': 'now()'</p><p>}).execute()</p><p># ‚îÄ‚îÄ ACTIVATE PREMIUM ‚îÄ‚îÄ</p><p>from datetime import datetime, timedelta</p><p>expires = (datetime.utcnow() + timedelta(days=30)).isoformat()</p><p>grace   = (datetime.utcnow() + timedelta(days=33)).isoformat()</p><p>supabase.table('users').update({</p><p>    'plan': 'ind_monthly',</p><p>    'premium_until': expires,</p><p>    'grace_until': grace,</p><p>    'last_paid_at': 'now()'</p><p>}).eq('telegram_user_id', str(user_id)).execute()</p><p># ‚îÄ‚îÄ CHECK CACHE (image) ‚îÄ‚îÄ</p><p>cached = supabase.table('check_cache')</p><p>    .select('*')</p><p>    .eq('content_hash', sha256_hash)</p><p>    .eq('check_type', 'image')</p><p>    .gte('expires_at', 'now()')</p><p>    .single().execute()</p><p>if cached.data: return cached.data   # Cache hit</p></td></tr></table><h2><strong>7.3 Error Handling Pattern</strong></h2><table><tr><td><p>from postgrest.exceptions import APIError</p><p>try:</p><p>    result = supabase.table('users').select('*')</p><p>        .eq('telegram_user_id', str(user_id)).single().execute()</p><p>    return result.data</p><p>except APIError as e:</p><p>    if 'PGRST116' in str(e):  # No rows found</p><p>        return None            # User doesn't exist yet</p><p>    logger.error(f'Supabase error: {e}')</p><p>    raise  # Re-raise unexpected errors</p></td></tr></table><table><tr><td><p><strong>üìå Document Status</strong></p><p>Document 9 of 13 ‚Äî COMPLETE</p><p>Next: Document 10 ‚Äî Database Schema (complete Supabase table definitions,</p><p>column types, indexes, RLS policies, and migration scripts)</p><p>How to use this document:</p><p>  ‚Üí Give your AI IDE the relevant section when building each integration.</p><p>  ‚Üí The complete integration functions in each section are copy-paste ready.</p><p>  ‚Üí Always implement the timeout and error handling exactly as shown ‚Äî</p><p>    missing timeouts will cause the bot to hang under load.</p><p>  ‚Üí The URL combining function in Section 4.6 is the most important function</p><p>    in the link detection flow ‚Äî implement it exactly as specified.</p></td></tr></table>